<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=1024" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <title>一个基于属性匹配的函数式对象映射系统的设计</title>

    <meta name="description" content="impress.js is a presentation tool based on the power of CSS3 transforms and transitions in modern browsers and inspired by the idea behind prezi.com." />
    <meta name="author" content="Bartek Szopka" />

    <link href="./impress.js/css/impress-demo.css" rel="stylesheet" />

    <link rel="stylesheet" href="./impress.js/extras/highlight/styles/github.css" />

    <link href="./impress.css/markdown-slides.css" rel="stylesheet" />
    <link href="./impress.css/devopsy.css" rel="stylesheet" />
    <link href="./impress.css/effects.css" rel="stylesheet" />
    <link href="./impress.css/index.css" rel="stylesheet" />

    <link rel="shortcut icon" href="./impress.js/favicon.png" />
    <link rel="apple-touch-icon" href="./impress.js/apple-touch-icon.png" />
</head>

<body class="impress-not-supported impress-on-markdown">

<div class="fallback-message">
    <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
    <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
</div>

<div id="impress">

    <div id="bored" class="step slide markdown" data-x="-1000" data-y="-1500">
# 一个基于属性匹配的函数式对象映射系统的设计
## by 水山清风
    </div>

    <div class="step slide markdown" data-x="0" data-y="-1500">
## 背景知识
- slick: 数据库操作框架(函数式关系映射)
- circe: 最流行的 scala json 库之一(Generic derivation)
- play: 最流行的 scala web 框架,本次主要讨论 json 和 BodyParser 部分
- DTO(Data Transfer Object): 数据传输对象
    </div>

    <div class="step slide markdown" data-x="1000" data-y="-1500">
## 课题一
- 改进 circe
##

    case class User(id: Option[Int], first: String, last: String)
    val userJson = io.circe.parser.parse("{ \"id\": 123, \"first\": \"firstName\", \"last\": \"lastName\" }")
    userJson.as[User]

##

- 问题1
- 不能处理特例,遇到
##

    { "id": "123", "first": "firstName", "last": "lastName" }

##

- 只能手写 Decoder,不能智能识别
    </div>

    <div id="title" class="step slide markdown" data-x="0" data-y="0" data-scale="1">
## 期望代码

    case class User(id: Option[Int], first: String, last: String)
    object Table {
      val id = Decoder.decodeJson.emapTry { json =>
        if (json.isString)
          json.as[String].toTry.map(_.toInt)
        else
          json.as[Int].toTry
        }
    }
    val userJson = io.circe.parser.parse("{ \"id\": \"123\", \"first\": \"firstName\", \"last\": \"lastName\" }")
    decodeWithTable[User](Table)(userJson) //Right(User(Option(123), firstName, lastName))

- 只声明要特殊处理的列
    </div>

    <div id="its" class="step slide markdown" data-x="850" data-y="3000" data-rotate="90" data-scale="1">
- 问题2
- 编译速度缓慢
- 原因: 无法并发获取 HList 的隐式转换
- circe 解决方案: 重写 shapeless 部分功能
- 缺点: 难度大,没有可以适配其他库的通用 api
- 问题3
- 无法调试或调试困难,发生编译错误时难以定位出现问题的属性
    </div>

    <div id="big" class="step slide markdown" data-x="3500" data-y="2100" data-rotate="180" data-scale="1">
## 课题二
- 改进 slick
##

    case class User(id: Option[Int], first: String, last: String)

    class Users(tag: Tag) extends Table[User](tag, "users") {
        def id = column[Int]("id", O.PrimaryKey, O.AutoInc)
        def first = column[String]("first")
        def last = column[String]("last")
        def * = (id.?, first, last) <> (User.tupled, User.unapply)
    }
    val users = TableQuery[Users]
    </div>

    <div id="tiny" class="step slide markdown" data-x="2825" data-y="2325" data-z="-3000" data-rotate="300" data-scale="1">
- 问题1
- 无法自动映射属性
- 问题2
- 超过 22 字段的大表将会把问题 1 放大数倍,造成维护困难
- 问题3
- 与 circe 相同,编译速度缓慢,超过 100 字段的表编译一次需要 20s+
- 问题4
- 与 circe 相反,slick 处处特例,无法省略没有特殊需求的列声明
- 问题5
- 与 circe 的问题相同,无法调试或调试困难.发生编译错误时难以定位出现问题的属性
    </div>

    <div id="ing" class="step slide markdown" data-x="3500" data-y="-850" data-z="0" data-rotate="270" data-scale="2">
## 期望代码一

    case class User(id: Option[Int], first: String, last: String)

    class Users(tag: Tag) extends Table[User](tag, "users") {
        def id = column[Int]("id", O.PrimaryKey, O.AutoInc)
        def first = column[String]("first")
        def last = column[String]("last")
        def * = autoMapper[User](this) //自动映射
    }
    val users = TableQuery[Users]
    </div>

    <div id="imagination" class="step slide markdown" data-x="6700" data-y="-300" data-scale="1">
## 期望代码二

    case class User(id: Option[Int], first: String, last: String)

    class Users(tag: Tag) extends Table[User](tag, "users") with AutoMapperHelper {
        def id = column[Int]("id", O.PrimaryKey, O.AutoInc)
        def * = autoMapper[User](this) //自动创建遵循默认行为的列
    }
    val users = TableQuery[Users]
    </div>

    <div id="source" class="step slide markdown" data-x="6300" data-y="2000" data-rotate="20" data-scale="4">
# 核心问题:
# 我们需要一个对象到对象的自动映射系统
    </div>

    <div id="one-more-thing" class="step slide markdown" data-x="6000" data-y="4000" data-scale="2">
- 我们需要一个对象到对象的自动映射系统
- 目标:
1. 1.匹配规则必须直观
1. 做法:基于属性名称匹配
1. 2.足够通用,可以面对几乎所有特有的或普遍的类型系统
1. 做法:不使用 Monad,自建抽象
1. 较普遍的类型系统: circe, play-json
1. 特有的类型系统: slick, shapeless 相关, tuple 相关
1. 反例:无法处理的类型系统: quill,原因:深度 Macro 相关
1. 3.动态映射和静态映射可以同时存在
1. 既能映射静态的普通类型对象属性,也能映射动态的集合属性(List, Map, JsonObject)
    </div>

    <div id="its-in-3d" class="step slide markdown" data-x="8200" data-y="4300" data-z="-100" data-rotate-x="-40" data-rotate-y="10" data-scale="2">
- 目标:
1. 4.类型系统可推导性强
1. 做法:类型驱动
1. 5.较快的编译速度
1. 解决方法:见下文
1. 6.可调试,可定位的编译期错误
1. 解决方法:见下文
    </div>

    <div id="page-01" class="step slide markdown" data-x="9300" data-y="4600" data-z="40" data-rotate-x="80" data-rotate-y="10" data-scale="1">
- 难点:
1. 1.不能存在性能问题
1. 解决方法1:不使用任何运行时反射(Macro, Implicit)
1. 解决方法2:不限定任何特定中间数据格式
1. 2.任何时候不可以回退到非自动映射
1. 3.Macro 模块代码要易于维护和理解
1. 4.万一 Macro 模块失效,需要提供一定的回退措施
1. 5.不能有 22 限制
    </div>

    <div id="page-02" class="step slide markdown" data-x="200" data-y="1900" data-z="24" data-rotate-x="14" data-rotate-y="78" data-scale="1">
# 接下来一小时,让我们开始艰难的系统设计
### 项目源码地址: [scalax/asuna](https://github.com/scalax/asuna)
    </div>

    <div id="page-03" class="step slide markdown" data-x="100" data-y="1000" data-z="0" data-rotate-x="-30" data-rotate-y="-17" data-scale="1">
# 最简单的对象映射情况
## java 模式的 DTO(Data Transfer Object)

    case class Foo(name: String, id: Int, age: Int)
    case class Bar(id: Int, name: String, age: Int)
    val convert: Foo => Bar = ???
    </div>

    <div id="page-04" class="step slide markdown" data-x="-600" data-y="1800" data-z="4" data-rotate-x="-20" data-rotate-y="-17" data-scale="1">
### 属性匹配规则:按顺序匹配 vs 按名称匹配
- 按顺序匹配:
- 现有支持: shapeless
- 优点: 1.支持完善
- 缺点: 1.难以赋予 HList 的 index 实际意义,必须保持严格的先后顺序对应关系
- 2.数据结构修改后难以维护
- 3.HList 提升编译速度的难度较大
- 4.不能处理数据源不一定是 case class 的情况
    </div>

    <div id="page-05" class="step slide markdown" data-x="-800" data-y="600" data-z="1" data-rotate-x="80" data-rotate-y="260" data-scale="1">
### 属性匹配规则:按顺序匹配 vs 按名称匹配
- 按名称匹配:
- 现有支持: 无或只有简单的 case class copy 支持([kailuowang/henkan](https://github.com/kailuowang/henkan))
- 优点: 1.实现比较自由,可以实现更多自定义映射规则
- 2.匹配规则比较直观,容易在对象间互相查找对应的属性
- 3.不需要关心顺序,在定义时和维护时更友好
- 4.调优空间大
- 缺点: 1.宏的实现十分复杂
- 2.目前的宏将会被 scala 抛弃(有新的替代)
    </div>

    <div id="page-06" class="step slide markdown" data-x="-1000" data-y="-600" data-z="1" data-rotate-x="-20" data-rotate-y="40" data-scale="0.8">
# 结论: 按属性名称匹配
    </div>

    <div id="page-07" class="step slide markdown" data-x="0" data-y="-600" data-z="200" data-rotate-x="12" data-rotate-y="20" data-scale="1">
## DTO 实现结果

    case class Foo(name: String, id: Int, age: Int)
    case class Bar(id: Int, name: String, age: Int)

    val convert: Foo => Bar = { fooModel: Foo =>
        dto.effect(dto.singleModel[Bar](fooModel).compile).value
    }

    val foo = Foo("name", 1234, 6789)

    println(foo) //Foo(name,1234,6789)
    println(convert(foo)) //Bar(1234,name,6789)

- 特点: 1.按名称匹配
- 2.类型安全
- 3.没有运行时反射,保证性能
    </div>

    <div id="overview" class="step" data-x="3000" data-y="1500" data-z="0" data-scale="10">
    </div>

</div>

<div id="impress-toolbar"></div>

<script>
if ("ontouchstart" in document.documentElement) {
    document.querySelector(".hint").innerHTML = "<p>Swipe left or right to navigate</p>";
}
</script>

<!-- Extra modules
     Load highlight.js, mermaid.js and markdown.js from extras.
     See also src/plugins/extras/extras.js -->
<script type="text/javascript" src="./impress.css/jquery-3.3.1.min.js"></script>
<script type="text/javascript" src="./impress.js/extras/highlight/highlight.pack.js"></script>
<script type="text/javascript" src="./impress.js/extras/mermaid/mermaid.min.js"></script>
<script type="text/javascript" src="./impress.js/extras/markdown/markdown.js"></script>

<script src="./impress.js/js/impress.js"></script>
<script>
$(function() {
    impress().init();

    $.map($("code"), function(item, index) {
        if (index === 1) {
            $(item).addClass("json");
        } else {
            $(item).addClass("scala");
        }
    });

    $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});


</script>

</body>
</html>