<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=1024" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <title>一个基于属性匹配的函数式对象映射系统的设计</title>

    <meta name="description" content="impress.js is a presentation tool based on the power of CSS3 transforms and transitions in modern browsers and inspired by the idea behind prezi.com." />
    <meta name="author" content="Bartek Szopka" />

    <link href="./impress.js/css/impress-demo.css" rel="stylesheet" />

    <link rel="stylesheet" href="./impress.js/extras/highlight/styles/github.css" />

    <link href="./impress.css/markdown-slides.css" rel="stylesheet" />
    <link href="./impress.css/devopsy.css" rel="stylesheet" />
    <link href="./impress.css/effects.css" rel="stylesheet" />
    <link href="./impress.css/index.css" rel="stylesheet" />

    <link rel="shortcut icon" href="./impress.js/favicon.png" />
    <link rel="apple-touch-icon" href="./impress.js/apple-touch-icon.png" />
</head>

<body class="impress-not-supported impress-on-markdown">

<div class="fallback-message">
    <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
    <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
</div>

<div id="impress">

    <div id="bored" class="step slide markdown markdown-title" data-x="-1000" data-y="-1500">
# 一个基于属性匹配的函数式对象映射系统的设计
## by 水山清风
    </div>

    <div class="step slide markdown" data-x="0" data-y="-1500">
## 背景知识
- slick: 数据库操作框架(函数式关系映射)
- circe: 最流行的 scala json 库之一(Generic derivation)
- play: 最流行的 scala web 框架,本次主要讨论 json 和 BodyParser 部分
- DTO(Data Transfer Object): 数据传输对象
    </div>

    <div class="step slide markdown" data-x="1000" data-y="-1500">
## 课题一
- 改进 circe

        case class User(id: Option[Int], first: String, last: String)
        val userJson = io.circe.parser.parse("{ \"id\": 123, \"first\": \"firstName\", \"last\": \"lastName\" }")
        userJson.as[User]

- 问题1
- 不能处理特例,遇到

        { "id": "123", "first": "firstName", "last": "lastName" }

只能手写 Decoder,不能智能识别
    </div>

    <div id="title" class="step slide markdown" data-x="0" data-y="0" data-scale="1">
## 期望代码

    case class User(id: Option[Int], first: String, last: String)
    object Table {
      val id = Decoder.decodeJson.emapTry { json =>
        if (json.isString)
          json.as[String].toTry.map(_.toInt)
        else
          json.as[Int].toTry
        }
    }
    val userJson = io.circe.parser.parse("{ \"id\": \"123\", \"first\": \"firstName\", \"last\": \"lastName\" }")
    decodeWithTable[User](Table)(userJson) //Right(User(Option(123), firstName, lastName))

- 只声明要特殊处理的列
    </div>

    <div id="its" class="step slide markdown" data-x="850" data-y="3000" data-rotate="90" data-scale="1">
- 问题2
- 编译速度缓慢
- 原因: 无法并发获取 HList 的隐式转换
- ciece 解决方案: 重写 shapeless 部分功能
- 缺点: 难度大,没有可以适配其他库的通用 api
- 问题3
- 无法调试或调试困难,发生编译错误时难以定位出现问题的属性
    </div>

    <div id="big" class="step slide markdown" data-x="3500" data-y="2100" data-rotate="180" data-scale="1">
## 课题二
- 改进 slick

        case class User(id: Option[Int], first: String, last: String)

        class Users(tag: Tag) extends Table[User](tag, "users") {
            def id = column[Int]("id", O.PrimaryKey, O.AutoInc)
            def first = column[String]("first")
            def last = column[String]("last")
            def * = (id.?, first, last) <> (User.tupled, User.unapply)
        }
        val users = TableQuery[Users]
    </div>

    <div id="tiny" class="step slide markdown" data-x="2825" data-y="2325" data-z="-3000" data-rotate="300" data-scale="1">
- 问题1
- 无法自动映射属性
- 问题2
- 超过 22 字段的大表将会把问题 1 放大数倍,造成维护困难
- 问题3
- shapeless 公共问题,编译缓慢,超过 100 字段的表编译一次需要 20s+
- 问题4
- 与 circe 相反,slick 处处特例,无法省略没有特殊需求的列声明
- 问题5
- 与 circe 的问题相同,无法调试或调试困难.发生编译错误时难以定位出现问题的属性
    </div>

    <div id="ing" class="step slide markdown" data-x="3500" data-y="-850" data-z="0" data-rotate="270" data-scale="2">
## 期望代码一

    case class User(id: Option[Int], first: String, last: String)

    class Users(tag: Tag) extends Table[User](tag, "users") {
        def id = column[Int]("id", O.PrimaryKey, O.AutoInc)
        def first = column[String]("first")
        def last = column[String]("last")
        def * = autoMapper[User](this) //自动映射
    }
    val users = TableQuery[Users]
    </div>

    <div id="imagination" class="step slide markdown" data-x="6700" data-y="-300" data-scale="1">
## 期望代码二

    case class User(id: Option[Int], first: String, last: String)

    class Users(tag: Tag) extends Table[User](tag, "users") with AutoMapperHelper {
        def id = column[Int]("id", O.PrimaryKey, O.AutoInc)
        def * = autoMapper[User](this) //自动创建遵循默认行为的列
    }
    val users = TableQuery[Users]
    </div>

    <div id="source" class="step slide markdown" data-x="6300" data-y="2000" data-rotate="20" data-scale="4">
# 核心问题:
# 我们需要一个对象到对象的自动映射系统
    </div>

    <div id="one-more-thing" class="step slide markdown" data-x="6000" data-y="4000" data-scale="2">
- 我们需要一个对象到对象的自动映射系统
- 难点:
1. 1.匹配规则必须直观
1. 解决方法:基于属性名称匹配
1. 2.不能存在性能问题
1. 解决方法1:不使用任何运行时反射(Macro, Implicit)
1. 解决方法2:不限定任何特定中间数据格式
1. 3.足够通用,可以面对几乎所有特有的或普遍的类型系统
1. 解决方法:不能使用 Monad,自建抽象
1. 较普遍的类型系统: circe, play-json
1. 特有的类型系统: slick, shapeless 相关, tuple 相关
1. 反例:无法处理的类型系统: quill,原因:深度 Macro 相关
    </div>

    <div id="its-in-3d" class="step slide markdown" data-x="8200" data-y="4300" data-z="-100" data-rotate-x="-40" data-rotate-y="10" data-scale="2">
- 难点:
1. 4.类型系统可推导性强
1. 解决方法:类型驱动的设计
1. 5.任何时候都可以自动匹配,不能因为各种情况回退到原始 api
1. 解决方法:见下文
1. 6.较快的编译速度
1. 解决方法:见下文
1. 7.可调试,可定位的编译期错误
1. 解决方法:见下文
1. 8.维护性良好的 Macro 模块
    </div>

    <div id="overview" class="step" data-x="3000" data-y="1500" data-z="0" data-scale="10">
    </div>

</div>

<div id="impress-toolbar"></div>

<script>
if ("ontouchstart" in document.documentElement) {
    document.querySelector(".hint").innerHTML = "<p>Swipe left or right to navigate</p>";
}
</script>

<!-- Extra modules
     Load highlight.js, mermaid.js and markdown.js from extras.
     See also src/plugins/extras/extras.js -->
<script type="text/javascript" src="./jquery-3.3.1.min.js"></script>
<script type="text/javascript" src="./impress.js/extras/highlight/highlight.pack.js"></script>
<script type="text/javascript" src="./impress.js/extras/mermaid/mermaid.min.js"></script>
<script type="text/javascript" src="./impress.js/extras/markdown/markdown.js"></script>

<script src="./impress.js/js/impress.js"></script>
<script>
$(function() {
    impress().init();

    $($("code")[0]).addClass("scala");
    $($("code")[1]).addClass("json");
    $($("code")[2]).addClass("scala");
    $($("code")[3]).addClass("scala");

    $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});


</script>

</body>
</html>