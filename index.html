<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=1024" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <title>一个基于属性匹配的函数式对象映射系统的设计</title>

    <meta name="description" content="impress.js is a presentation tool based on the power of CSS3 transforms and transitions in modern browsers and inspired by the idea behind prezi.com." />
    <meta name="author" content="Bartek Szopka" />

    <link href="./impress.js/css/impress-demo.css" rel="stylesheet" />

    <link rel="stylesheet" href="./impress.js/extras/highlight/styles/github.css" />

    <link href="./impress.css/markdown-slides.css" rel="stylesheet" />
    <link href="./impress.css/devopsy.css" rel="stylesheet" />
    <link href="./impress.css/effects.css" rel="stylesheet" />
    <link href="./impress.css/index.css" rel="stylesheet" />

    <link rel="shortcut icon" href="./impress.js/favicon.png" />
    <link rel="apple-touch-icon" href="./impress.js/apple-touch-icon.png" />
</head>

<body class="impress-not-supported impress-on-markdown">

<div class="fallback-message">
    <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
    <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
</div>

<div id="impress">

    <div id="bored" class="step slide markdown" data-x="-1000" data-y="-1500">
# 一个基于属性匹配的函数式对象映射系统的设计
## by 水山清风
    </div>

    <div class="step slide markdown" data-x="0" data-y="-1500">
## 背景知识
- slick: 数据库操作框架(函数式关系映射)
- circe: 最流行的 scala json 库之一(Generic derivation)
- play: 最流行的 scala web 框架,本次主要讨论 json 和 BodyParser 部分
- DTO(Data Transfer Object): 数据传输对象
    </div>

    <div class="step slide markdown" data-x="1000" data-y="-1500">
## 课题一
- 改进 circe
##

    case class User(id: Option[Int], first: String, last: String)
    val userJson = io.circe.parser.parse("{ \"id\": 123, \"first\": \"firstName\", \"last\": \"lastName\" }")
    userJson.as[User]

##

- 问题1
- 不能处理特例,遇到
##

    { "id": "123", "first": "firstName", "last": "lastName" }

##

- 只能手写 Decoder,不能智能识别
    </div>

    <div id="title" class="step slide markdown" data-x="0" data-y="0" data-scale="1">
## 期望代码

    case class User(id: Option[Int], first: String, last: String)
    object Table {
      val id = Decoder.decodeJson.emapTry { json =>
        if (json.isString)
          json.as[String].toTry.map(_.toInt)
        else
          json.as[Int].toTry
        }
    }
    val userJson = io.circe.parser.parse("{ \"id\": \"123\", \"first\": \"firstName\", \"last\": \"lastName\" }")
    decodeWithTable[User](Table)(userJson) //Right(User(Option(123), firstName, lastName))

- 只声明要特殊处理的列
    </div>

    <div id="its" class="step slide markdown" data-x="850" data-y="3000" data-rotate="90" data-scale="1">
- 问题2
- 编译速度缓慢
- 原因: 无法并发获取 HList 的隐式转换
- circe 解决方案: 重写 shapeless 部分功能
- 缺点: 难度大,没有可以适配其他库的通用 api
- 问题3
- 无法调试或调试困难,发生编译错误时难以定位出现问题的属性
    </div>

    <div id="big" class="step slide markdown" data-x="3500" data-y="2100" data-rotate="180" data-scale="1">
## 课题二
- 改进 slick
##

    case class User(id: Option[Int], first: String, last: String)

    class Users(tag: Tag) extends Table[User](tag, "users") {
        def id = column[Int]("id", O.PrimaryKey, O.AutoInc)
        def first = column[String]("first")
        def last = column[String]("last")
        def * = (id.?, first, last) <> (User.tupled, User.unapply)
    }
    val users = TableQuery[Users]
    </div>

    <div id="tiny" class="step slide markdown" data-x="2825" data-y="2325" data-z="-3000" data-rotate="300" data-scale="1">
- 问题1
- 无法自动映射属性
- 问题2
- 超过 22 字段的大表将会把问题 1 放大数倍,造成维护困难
- 问题3
- 与 circe 相同,编译速度缓慢,超过 100 字段的表编译一次需要 20s+
- 问题4
- 与 circe 相反,slick 处处特例,无法省略没有特殊需求的列声明
- 问题5
- 与 circe 的问题相同,无法调试或调试困难.发生编译错误时难以定位出现问题的属性
    </div>

    <div id="ing" class="step slide markdown" data-x="3500" data-y="-850" data-z="0" data-rotate="270" data-scale="2.6">
## 期望代码一

    case class User(id: Option[Int], first: String, last: String)

    class Users(tag: Tag) extends Table[User](tag, "users") {
        def id = column[Int]("id", O.PrimaryKey, O.AutoInc)
        def first = column[String]("first")
        def last = column[String]("last")
        def * = autoMapper[User](this) //自动映射
    }
    val users = TableQuery[Users]
    </div>

    <div id="imagination" class="step slide markdown" data-x="6700" data-y="-300" data-scale="1">
## 期望代码二

    case class User(id: Option[Int], first: String, last: String)

    class Users(tag: Tag) extends Table[User](tag, "users") with AutoMapperHelper {
        def id = column[Int]("id", O.PrimaryKey, O.AutoInc)
        def * = autoMapper[User](this) //自动创建遵循默认行为的列
    }
    val users = TableQuery[Users]
    </div>

    <div id="source" class="step slide markdown" data-x="6300" data-y="2000" data-rotate="20" data-scale="4">
# 核心问题:
# 我们需要一个对象到对象的自动映射系统
    </div>

    <div id="one-more-thing" class="step slide markdown" data-x="6000" data-y="4000" data-scale="2">
- 我们需要一个对象到对象的自动映射系统
- 目标:
1. 1.匹配规则必须直观
1. 做法:基于属性名称匹配
1. 2.足够通用,可以面对几乎所有特有的或普遍的类型系统
1. 做法:不使用 Monad,自建抽象
1. 较普遍的类型系统: circe, play-json
1. 特有的类型系统: slick, shapeless 相关, tuple 相关
1. 反例:无法处理的类型系统: quill,原因:深度 Macro 相关
1. 3.动态映射和静态映射可以同时存在
1. 既能映射静态的普通类型对象属性,也能映射动态的集合属性(List, Map, JsonObject)
    </div>

    <div id="its-in-3d" class="step slide markdown" data-x="8200" data-y="4300" data-z="-100" data-rotate-x="-40" data-rotate-y="10" data-scale="2">
- 目标:
1. 4.类型系统可推导性强
1. 做法:类型驱动
1. 5.较快的编译速度
1. 解决方法:见下文
1. 6.可调试,可定位的编译期错误
1. 解决方法:见下文
    </div>

    <div id="page-01" class="step slide markdown" data-x="9300" data-y="4600" data-z="40" data-rotate-x="80" data-rotate-y="10" data-scale="1">
- 难点:
1. 1.不能存在性能问题
1. 解决方法1:不使用任何运行时反射(Macro, Implicit)
1. 解决方法2:不限定任何特定中间数据格式
1. 2.任何时候不可以回退到非自动映射
1. 3.Macro 模块代码要易于维护和理解
1. 4.万一 Macro 模块失效,需要提供一定的回退措施
1. 5.不能有 22 限制
    </div>

    <div id="page-02" class="step slide markdown" data-x="200" data-y="1900" data-z="24" data-rotate-x="14" data-rotate-y="78" data-scale="1">
# 接下来一小时,让我们开始艰难的系统设计
### 项目源码地址: [scalax/asuna](https://github.com/scalax/asuna)
    </div>

    <div id="page-03" class="step slide markdown" data-x="100" data-y="1000" data-z="0" data-rotate-x="-30" data-rotate-y="-17" data-scale="1">
# 最简单的对象映射情况
## java 模式的 DTO(Data Transfer Object)

    case class Foo(name: String, id: Int, age: Int)
    case class Bar(id: Int, name: String, age: Int)
    val convert: Foo => Bar = ???
    </div>

    <div id="page-04" class="step slide markdown" data-x="-600" data-y="1800" data-z="4" data-rotate-x="-20" data-rotate-y="-17" data-scale="1">
### 属性匹配规则:按顺序匹配 vs 按名称匹配
- 按顺序匹配:
- 现有支持: shapeless
- 优点: 1.支持完善
- 缺点: 1.难以赋予 HList 的 index 实际意义,必须保持严格的先后顺序对应关系
- 2.数据结构修改后难以维护
- 3.HList 提升编译速度的难度较大
- 4.不能处理数据源不一定是 case class 的情况
    </div>

    <div id="page-05" class="step slide markdown" data-x="-800" data-y="600" data-z="1" data-rotate-x="80" data-rotate-y="260" data-scale="1">
### 属性匹配规则:按顺序匹配 vs 按名称匹配
- 按名称匹配:
- 现有支持: 无或只有简单的 case class copy 支持([kailuowang/henkan](https://github.com/kailuowang/henkan))
- 优点: 1.实现比较自由,可以实现更多自定义映射规则
- 2.匹配规则比较直观,容易在对象间互相查找对应的属性
- 3.不需要关心顺序,在定义时和维护时更友好
- 4.调优空间大
- 缺点: 1.宏的实现十分复杂
- 2.目前的宏将会被 scala 抛弃(有新的替代)
    </div>

    <div id="page-06" class="step slide markdown" data-x="-1000" data-y="-600" data-z="1" data-rotate-x="-20" data-rotate-y="40" data-scale="0.8">
# 结论: 按属性名称匹配
    </div>

    <div id="page-07" class="step slide markdown" data-x="0" data-y="-600" data-z="200" data-rotate-x="12" data-rotate-y="20" data-scale="1">
## DTO 实现结果

    case class Foo(name: String, id: Int, age: Int)
    case class Bar(id: Int, name: String, age: Int)

    val convert: Foo => Bar = { fooModel: Foo =>
        dto.effect(dto.singleModel[Bar](fooModel).compile).value
    }

    val foo = Foo("name", 1234, 6789)

    println(foo) //Foo(name,1234,6789)
    println(convert(foo)) //Bar(1234,name,6789)

- 特点: 1.按名称匹配
- 2.类型安全
- 3.没有运行时反射,保证性能
    </div>

    <div id="page-08" class="step slide markdown" data-x="1000" data-y="-600" data-z="-4000" data-rotate-x="-40" data-rotate-y="-40" data-scale="2">
### [示例代码](https://github.com/djx314/djx314.github.io/tree/master/lesson01/src/main/scala)
### 运行命令: sbt test01
    </div>

    <div id="page-10" class="step slide markdown" data-x="1000" data-y="100" data-z="-2000" data-rotate-x="82" data-rotate-y="17" data-scale="1">
## 然而,事情总不会那么美好
- scala 风格的 DTO
##

    case class Foo(name: Future[String], id: Either[Exception, Int], age: Future[Either[Exception, Int]])
    case class Bar(id: Int, name: String, age: Int)
    val convert: Foo => Bar = ???

##

- 或者
##

    object Foo {
        val name = Future.successful("name")
        val id = Right(1234)
        val age = Future.successful(Right(6789))
    }
    case class Bar(id: Int, name: String, age: Int)
    val newModel: Bar = ???
    </div>

    <div id="page-11" class="step slide markdown" data-x="1000" data-y="800" data-z="-600" data-rotate-x="12" data-rotate-y="17" data-scale="1">
## 新的实现
- [示例代码](https://github.com/djx314/djx314.github.io/tree/master/lesson02/src/main/scala)
- 运行命令: sbt test02
##

    val ec = scala.concurrent.ExecutionContext.Implicits.global

    val newModel: Future[Either[Exception, Bar]] =
    fe.effect(fe.singleModel[Bar](Foo).compile).data(ec)

    println(Await.result(newModel, Duration.Inf)) //Right(Bar(1234,name,6789))

##

- 小技巧: 无须直接引入 ExecutionContext,作为参数在最后传入即可,减少 implicit not found 时的不确定因素
- 开始简要介绍概念 DecoderShape
    </div>

    <div id="page-12" class="step slide markdown" data-x="1470" data-y="1900" data-z="-600" data-rotate-x="12" data-rotate-y="17" data-scale="1.6">
    case class SplitData[T, R](current: T, left: R)

    trait DecoderShape[-E, RepCol, DataCol] extends CommonShape[E, RepCol] {
        override type Target
        type Data
        override def packed: DecoderShape.Aux[Target, Data, Target, RepCol, DataCol]
        override def wrapRep(base: => E): Target
        override def buildRep(base: Target, oldRep: RepCol): RepCol
        def takeData(rep: Target, oldData: DataCol): SplitData[Data, DataCol]
    }

##

- RepCol 列的临时容器,例如 List[Decoder[_]]
- DataCol 数据的临时容器,例如 List[Any], (Any, Any)
- buildRep 叠加列
- takeData 取出根据协议由 RepCol 生成 DataCol 后的数据
- 重点:由 Any 类型到特定类型
    </div>

    <div id="page-13" class="step slide markdown" data-x="3170" data-y="1000" data-z="-600" data-rotate-x="12" data-rotate-y="17" data-scale="1.6">
    trait EncoderShape[-E, RepCol, DataCol] extends CommonShape[E, RepCol] {
        override type Target
        type Data
        override def packed: EncoderShape.Aux[Target, Data, Target, RepCol, DataCol]
        override def wrapRep(base: => E): Target
        override def buildRep(base: Target, oldRep: RepCol): RepCol
        def buildData(data: Data, rep: Target, oldData: DataCol): DataCol
    }

- RepCol 列的临时容器,例如 List[Decoder[_]]
- DataCol 数据的临时容器,例如 List[Any], (Any, Any)
- buildRep 叠加列
- buildData 由特定类型数据转化为 DataCol,再根据协议与 RepCol 发生作用
- 重点:由特定类型到 Any 类型
    </div>

    <div id="page-14" class="step slide markdown" data-x="-600" data-y="3000" data-z="200" data-rotate-x="62" data-rotate-y="33" data-scale="1.4">
    trait FormatterShape[-E, RepCol, EncoderDataCol, DecoderDataCol]
    extends EncoderShape[E, RepCol, EncoderDataCol] with DecoderShape[E, RepCol, DecoderDataCol]
    with CommonShape[E, RepCol] {
        override type Target
        override type Data
        override def packed: FormatterShape.Aux[Target, Data, Target, RepCol, EncoderDataCol, DecoderDataCol]
        override def wrapRep(base: => E): Target
        override def buildRep(base: Target, oldRep: RepCol): RepCol
        override def takeData(rep: Target, oldData: DecoderDataCol): SplitData[Data, DecoderDataCol]
        override def buildData(data: Data, rep: Target, oldData: EncoderDataCol): EncoderDataCol
    }

- EncoderShape, DecoderShape 兼而有之
- DataCol 不统一, RepCol 统一
    </div>

    <div id="page-15" class="step slide markdown" data-x="-600" data-y="4200" data-z="200" data-rotate-x="11" data-rotate-y="4" data-scale="1">
## ShapeValue 介绍

    trait DecoderShapeValue[U, RepCol, DataCol] extends CommonShapeValue[U, RepCol] {
        override type RepType
        override val rep: RepType
        override val shape: DecoderShape.Aux[RepType, U, RepType, RepCol, DataCol]
    }

- 带 rep 的 DecoderShapeValue, 自动提供 DecoderShape.
- 同理 EncoderShapeValue, FormatterShapeValue
    </div>

    <div id="page-16" class="step slide markdown" data-x="600" data-y="4200" data-z="200" data-rotate-x="-124" data-rotate-y="71" data-scale="1">
## 一般映射流程

    context.effect(context.singleModel[CaseClass](table).compile)
    </div>

    <div id="page-17" class="step slide markdown" data-x="1200" data-y="4200" data-z="-800" data-rotate-x="211" data-rotate-y="1" data-scale="1">
## singleModel 实现的 3 个版本
- 1.只使用 Macro
- 难度大
- 代码难以维护
- 扩展性差
- 难以推导
- 无法处理 `shapeless.Lazy` 的情况
    </div>

    <div id="page-18" class="step slide markdown" data-x="2400" data-y="4200" data-z="-800" data-rotate-x="-60" data-rotate-y="14" data-scale="1">
- 2.使用 HList(非 shapeless)
- 易于推理
- 没有 22 限制
- 编译缓慢
- 大对象难以调试
    </div>

    <div id="page-19" class="step slide markdown" data-x="4200" data-y="4200" data-z="200" data-rotate-x="11" data-rotate-y="4" data-scale="1">
- 3.使用 tuple(非 scala 原生 tuple)
##

    implicit def hlistDecoderImplicit2[A, B <: HList, H, I <: HList, M, N <: HList, RepCol, DataCol](
        implicit head: Lazy[DecoderShape.Aux[A, H, M, RepCol, DataCol]]
        , tail: Lazy[DecoderShape.Aux[B, I, N, RepCol, DataCol]]
    ): DecoderShape.Aux[A :: B, H :: I, M :: N, RepCol, DataCol]

##

- HList 只能逐列推理
##

    implicit def caseClassHelper2DecoderGen[Rep1, Data1, Target1, Rep2, Data2, Target2, RepCol, DataCol](
        implicit
        shape1: DecoderShape.Aux[Rep1, Data1, Target1, RepCol, DataCol]
        , shape2: DecoderShape.Aux[Rep2, Data2, Target2, RepCol, DataCol]
    ): DecoderShape.Aux[CaseClassRepMapper2[Rep1, Data1, Rep2, Data2], CaseClassDataMapper2[Data1, Data2], CaseClassRepMapper2[Target1, Data1, Target2, Data2], RepCol, DataCol]

- tuple 更容易同时获取多个 implicit
    </div>

    <div id="page-20" class="step slide markdown" data-x="4200" data-y="3400" data-z="14" data-rotate-x="-24" data-rotate-y="14" data-scale="1">
- 1.避免与 scala.Tuple 产生冲突,采用自建 tuple
- 2.自建 tuple 最大元素数量为 6
- 3.在 Macro 方面采用嵌套 tuple 突破 22 限制
- 4.采用 code gen 生成所有的辅助类和 implicit

### 在 100 列的 slick table 中,编译时间由原生 api 的 24s 降低到 6s
    </div>

    <div id="page-21" class="step slide markdown" data-x="3000" data-y="3200" data-z="-26" data-rotate-x="14" data-rotate-y="14" data-scale="1">
# 到目前为止,一切都很美好
    </div>

    <div id="page-22" class="step slide markdown" data-x="2000" data-y="3100" data-z="14" data-rotate-x="14" data-rotate-y="171" data-scale="1">
### 我们不仅仅需要把属性对应起来
- 我们需要省略无用的声明
- 我们需要 LabelGeneric
- 我们需要在任何时候都不回退到原始 api
- 任何时候不能带来数量级的属性声明增长
- 高阶类型带来的问题尚未完全解决
### 通过 slick 的例子阐述大部分问题
    </div>

    <div id="page-23" class="step slide markdown" data-x="2000" data-y="-1200" data-z="-40" data-rotate-x="14" data-rotate-y="171" data-rotate="270" data-scale="1">
## slick + asuna 概述
- 项目地址: [scalax/shino](https://github.com/scalax/shino)
- 普通自动映射 [reader](https://github.com/scalax/shino/blob/master/README_reader.md) [writer](https://github.com/scalax/shino/blob/master/README_writer.md) [formatter](https://github.com/scalax/shino/blob/master/README_formatter.md)
- 动态 sortby 映射
- 动态取列
    </div>

    <div id="page-24" class="step slide markdown" data-x="5200" data-y="-1200" data-z="2" data-rotate-x="14" data-rotate-y="171" data-rotate="240" data-scale="1">
## 处理属性重写
- 1.定义时重写
##

    class FriendTable(tag: slick.lifted.Tag) extends Table[Friend](tag, "firend") with SlickResultIO {
        def id   = column[Long]("id", O.AutoInc)
        //...
        @OverrideProperty("id")
        def id_? = id.?

        override def * = shino.effect(shino.singleModel[Friend](this).compile).shape
    }

- `id_?` 可以是其他无关的属性名称
    </div>

    <div id="page-25" class="step slide markdown" data-x="6400" data-y="-1200" data-z="2" data-rotate-x="14" data-rotate-y="140" data-rotate="220" data-scale="1">
- 2.对原对象低侵入的重写
##

    class FriendTable(tag: slick.lifted.Tag) extends Table[Friend](tag, "firend") with SlickResultIO {
    self =>
        def id   = column[Long]("id", O.AutoInc)
        def name = column[String]("name")
        def nick = column[String]("nick")
        def age  = column[Int]("age")
        override def * = shino.effect(shino.singleModel[Friend](new FriendTableExt { override val ft = self }: FriendTableExt).compile).shape
    }

    trait FriendTableExt {
        @RootTable val ft: FriendTable
        def id = ft.id.?
    }
    </div>

    <div id="overview" class="step" data-x="3000" data-y="1500" data-z="0" data-scale="10">
    </div>

</div>

<div id="impress-toolbar"></div>

<script>
if ("ontouchstart" in document.documentElement) {
    document.querySelector(".hint").innerHTML = "<p>Swipe left or right to navigate</p>";
}
</script>

<!-- Extra modules
     Load highlight.js, mermaid.js and markdown.js from extras.
     See also src/plugins/extras/extras.js -->
<script type="text/javascript" src="./impress.css/jquery-3.3.1.min.js"></script>
<script type="text/javascript" src="./impress.js/extras/highlight/highlight.pack.js"></script>
<script type="text/javascript" src="./impress.js/extras/mermaid/mermaid.min.js"></script>
<script type="text/javascript" src="./impress.js/extras/markdown/markdown.js"></script>

<script src="./impress.js/js/impress.js"></script>
<script>
$(function() {
    impress().init();

    $.map($("code"), function(item, index) {
        if (index === 1) {
            $(item).addClass("json");
        } else {
            $(item).addClass("scala");
        }
    });

    $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});


</script>

</body>
</html>